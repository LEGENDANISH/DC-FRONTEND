<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Call Test</title>
    <!-- Include Socket.IO Client Library -->
    <script src="/socket.io/socket.io.js"></script> 
    <!-- If serving from a different origin, use the full URL: -->
    <!-- <script src="http://localhost:YOUR_SERVER_PORT/socket.io/socket.io.js"></script> -->
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        video { width: 300px; height: 200px; border: 1px solid #ccc; margin: 5px; }
        #localVideo { background-color: #eee; }
        #remoteVideo { background-color: #ddd; }
        button { padding: 10px; margin: 5px; }
        #callControls { margin-top: 20px; }
        #messages { margin-top: 20px; white-space: pre-wrap; border: 1px solid #999; padding: 10px; height: 150px; overflow-y: scroll; }
    </style>
</head>
<body>
    <h1>WebRTC Call Test</h1>
    
    <div>
        <video id="localVideo" autoplay muted></video> <!-- Muted to avoid feedback -->
        <video id="remoteVideo" autoplay></video>
    </div>

    <div id="callControls">
        <button id="initiateCallBtn">Initiate Call (Voice)</button>
        <button id="initiateVideoCallBtn">Initiate Call (Video)</button>
        <button id="acceptCallBtn" disabled>Accept Call</button>
        <button id="declineCallBtn" disabled>Decline Call</button>
        <button id="endCallBtn" disabled>End Call</button>
        <button id="toggleMuteBtn" disabled>Mute/Unmute</button>
        <button id="toggleVideoBtn" disabled>Enable/Disable Video</button>
        <button id="startScreenShareBtn" disabled>Start Screen Share</button>
        <button id="stopScreenShareBtn" disabled>Stop Screen Share</button>
    </div>

    <div>
        <h3>Messages:</h3>
        <div id="messages"></div>
    </div>

    <script>
        // --- Configuration ---
        // IMPORTANT: Replace with your actual JWT token for the user
        const authToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJjbWV5aHoyM3IwMDByaTJmY3l5aXI0NmNrIiwiZW1haWwiOiJhbmlzaEBleGFtcGxlLmNvbSIsImlhdCI6MTc1Nzc4NzIwNywiZXhwIjoxNzU4MzkyMDA3fQ.KHLJVr3OFEjRy9upVzMDJigUl-5t2DRr9cjGAj0yaLU'; 
        // IMPORTANT: Replace with the ID of the user you want to call
        const targetUserId = 'cmfh8u3gf0000i2c85l3pzxa6'; 

        // --- State ---
        let socket;
        let currentCallId = null;
        let isAudioEnabled = true;
        let isVideoEnabled = true;
        // Placeholder for WebRTC connection (actual implementation needed)
        let peerConnection = null; 

        // --- DOM Elements ---
        const messagesDiv = document.getElementById('messages');
        const initiateCallBtn = document.getElementById('initiateCallBtn');
        const initiateVideoCallBtn = document.getElementById('initiateVideoCallBtn');
        const acceptCallBtn = document.getElementById('acceptCallBtn');
        const declineCallBtn = document.getElementById('declineCallBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const toggleMuteBtn = document.getElementById('toggleMuteBtn');
        const toggleVideoBtn = document.getElementById('toggleVideoBtn');
        const startScreenShareBtn = document.getElementById('startScreenShareBtn');
        const stopScreenShareBtn = document.getElementById('stopScreenShareBtn');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');

        // --- Utility ---
        function logMessage(message) {
            messagesDiv.textContent += `[${new Date().toLocaleTimeString()}] ${message}\n`;
            messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll
        }

        function disableCallButtons() {
            [acceptCallBtn, declineCallBtn, endCallBtn, toggleMuteBtn,
             toggleVideoBtn, startScreenShareBtn, stopScreenShareBtn].forEach(btn => btn.disabled = true);
        }

        function enableInCallButtons() {
             endCallBtn.disabled = false;
             toggleMuteBtn.disabled = false;
             toggleVideoBtn.disabled = false;
             startScreenShareBtn.disabled = false;
             // stopScreenShareBtn is enabled only when sharing starts
        }


        // --- Socket.IO Connection and Event Listeners ---
        function connectSocket() {
            // Connect to Socket.IO server with authentication token
            socket = io({ // Adjust path/port if needed, e.g., io('http://localhost:3000')
                auth: {
                    token: authToken
                }
            });

            socket.on('connect', () => {
                logMessage("Connected to Socket.IO server.");
                initiateCallBtn.disabled = false;
                initiateVideoCallBtn.disabled = false;
            });

            socket.on('connect_error', (err) => {
                 logMessage(`Connection Error: ${err.message}`);
                 disableCallButtons();
                 initiateCallBtn.disabled = true;
                 initiateVideoCallBtn.disabled = true;
            });

            socket.on('disconnect', (reason) => {
                logMessage(`Disconnected: ${reason}`);
                disableCallButtons();
                initiateCallBtn.disabled = true;
                initiateVideoCallBtn.disabled = true;
                currentCallId = null;
                 // Reset UI if needed
            });

            // --- Call Signaling Events ---

            socket.on('call_incoming', (data) => {
                logMessage(`Incoming call from ${data.caller.username} (${data.type})`);
                currentCallId = data.callId;
                // In a real app, show an incoming call UI
                acceptCallBtn.disabled = false;
                declineCallBtn.disabled = false;
                // For testing, auto-accept after a short delay
                // setTimeout(() => { if(currentCallId === data.callId) socket.emit('call_accept', { callId: data.callId }); }, 2000);
            });

            socket.on('call_initiated', (data) => {
                logMessage(`Call initiated to ${data.callee.username}. Waiting for response...`);
                currentCallId = data.callId;
                // Disable buttons while waiting
                disableCallButtons();
            });

            socket.on('call_accepted', (data) => {
                logMessage(`Call accepted. Call ID: ${data.callId}`);
                currentCallId = data.callId;
                enableInCallButtons();
                // --- START WEBRTC NEGOTIATION HERE ---
                // This is where you would typically create the RTCPeerConnection,
                // get user media, create an offer, and send it via 'webrtc_offer'.
                // Example (simplified):
                /*
                createPeerConnection(); // Function to set up RTCPeerConnection
                getUserMedia().then(stream => {
                    localVideo.srcObject = stream;
                    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
                    return peerConnection.createOffer();
                }).then(offer => {
                     return peerConnection.setLocalDescription(offer);
                }).then(() => {
                    socket.emit('webrtc_offer', {
                        callId: currentCallId,
                        targetUserId: targetUserId, // Or get callee ID from call state
                        offer: peerConnection.localDescription
                    });
                }).catch(err => {
                     logMessage(`WebRTC Offer Error: ${err}`);
                     socket.emit('call_end', { callId: currentCallId });
                });
                */
            });

            socket.on('call_ended', (data) => {
                logMessage(`Call ended. Reason: ${data.reason}`);
                currentCallId = null;
                disableCallButtons();
                initiateCallBtn.disabled = false;
                initiateVideoCallBtn.disabled = false;
                // Stop media tracks, close peer connection
                if (localVideo.srcObject) {
                    localVideo.srcObject.getTracks().forEach(track => track.stop());
                    localVideo.srcObject = null;
                }
                if (remoteVideo.srcObject) {
                     remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                     remoteVideo.srcObject = null;
                }
                // if (peerConnection) peerConnection.close(); // Close WebRTC connection
                // peerConnection = null;
            });

            socket.on('call_error', (data) => {
                logMessage(`Call Error: ${data.message}`);
                // Reset state/UI on error if necessary
                if (!currentCallId) { // If not in a call, re-enable initiate
                     initiateCallBtn.disabled = false;
                     initiateVideoCallBtn.disabled = false;
                }
            });

            // --- WebRTC Signaling Events ---
            socket.on('webrtc_offer', async (data) => {
                logMessage(`Received WebRTC Offer from ${data.senderId}`);
                // --- HANDLE OFFER HERE ---
                // Set remote description, create answer, set local description, send answer
                /*
                if (!peerConnection) createPeerConnection(); // Ensure connection exists
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    socket.emit('webrtc_answer', {
                        callId: data.callId,
                        targetUserId: data.senderId,
                        answer: peerConnection.localDescription
                    });
                } catch (err) {
                    logMessage(`Error handling offer: ${err}`);
                }
                */
            });

            socket.on('webrtc_answer', async (data) => {
                logMessage(`Received WebRTC Answer from ${data.senderId}`);
                // --- HANDLE ANSWER HERE ---
                // Set remote description
                /*
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                } catch (err) {
                    logMessage(`Error handling answer: ${err}`);
                }
                */
            });

            socket.on('webrtc_ice_candidate', async (data) => {
                // logMessage(`Received ICE Candidate from ${data.senderId}`); // Can be very verbose
                // --- HANDLE ICE CANDIDATE HERE ---
                // Add ICE candidate to peer connection
                /*
                try {
                   await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (err) {
                    // logMessage(`Error adding ICE candidate: ${err}`); // Can be frequent
                }
                */
            });

            // --- Other Call Events ---
            socket.on('screen_share_started', (data) => {
                 logMessage(`Screen share started by ${data.userId} (${data.username})`);
                 stopScreenShareBtn.disabled = false;
                 // The remote stream should automatically update to show the screen share
            });

            socket.on('screen_share_stopped', (data) => {
                 logMessage(`Screen share stopped by ${data.userId}`);
                 stopScreenShareBtn.disabled = true;
                 // The remote stream should revert to camera/video
            });

            socket.on('participant_state_update', (data) => {
                 logMessage(`Participant ${data.userId} updated state: Audio=${data.audioEnabled}, Video=${data.videoEnabled}`);
                 // Update UI to reflect remote participant's mute/video status (e.g., icons)
            });

        }

        // --- Button Event Listeners ---
        initiateCallBtn.addEventListener('click', () => {
            if (socket && socket.connected) {
                logMessage("Initiating voice call...");
                socket.emit('call_initiate', {
                    targetUserId: targetUserId,
                    type: 'voice'
                });
            } else {
                logMessage("Not connected to server.");
            }
        });

        initiateVideoCallBtn.addEventListener('click', () => {
            if (socket && socket.connected) {
                logMessage("Initiating video call...");
                socket.emit('call_initiate', {
                    targetUserId: targetUserId,
                    type: 'video'
                });
            } else {
                logMessage("Not connected to server.");
            }
        });

        acceptCallBtn.addEventListener('click', () => {
            if (socket && currentCallId) {
                logMessage("Accepting call...");
                socket.emit('call_accept', { callId: currentCallId });
                acceptCallBtn.disabled = true;
                declineCallBtn.disabled = true;
            }
        });

        declineCallBtn.addEventListener('click', () => {
            if (socket && currentCallId) {
                logMessage("Declining call...");
                socket.emit('call_decline', { callId: currentCallId });
                acceptCallBtn.disabled = true;
                declineCallBtn.disabled = true;
                currentCallId = null; // Reset locally
            }
        });

        endCallBtn.addEventListener('click', () => {
            if (socket && currentCallId) {
                logMessage("Ending call...");
                socket.emit('call_end', { callId: currentCallId });
                // UI update handled by 'call_ended' event
            }
        });

        toggleMuteBtn.addEventListener('click', () => {
             if (socket && currentCallId) {
                 isAudioEnabled = !isAudioEnabled;
                 logMessage(`Toggling audio: ${isAudioEnabled ? 'Enabled' : 'Disabled'}`);
                 
                 // Toggle local audio track mute state
                 if (localVideo.srcObject) {
                      localVideo.srcObject.getAudioTracks().forEach(track => {
                          track.enabled = isAudioEnabled;
                      });
                 }

                 // Notify other participant
                 socket.emit('call_state_update', {
                     callId: currentCallId,
                     audioEnabled: isAudioEnabled,
                     videoEnabled: isVideoEnabled // Send current state
                 });
             }
        });

        toggleVideoBtn.addEventListener('click', () => {
             if (socket && currentCallId) {
                 isVideoEnabled = !isVideoEnabled;
                 logMessage(`Toggling video: ${isVideoEnabled ? 'Enabled' : 'Disabled'}`);
                 
                 // Toggle local video track enabled state
                 if (localVideo.srcObject) {
                      localVideo.srcObject.getVideoTracks().forEach(track => {
                          track.enabled = isVideoEnabled;
                      });
                 }

                 // Notify other participant
                 socket.emit('call_state_update', {
                     callId: currentCallId,
                     audioEnabled: isAudioEnabled, // Send current state
                     videoEnabled: isVideoEnabled
                 });
             }
        });

        startScreenShareBtn.addEventListener('click', () => {
             if (socket && currentCallId) {
                 logMessage("Starting screen share...");
                 socket.emit('screen_share_start', { callId: currentCallId });
                 // Actual screen capture and adding stream to peer connection
                 // would happen after receiving 'screen_share_start_confirmed'
                 // or directly here if not waiting for confirmation.
             }
        });

        stopScreenShareBtn.addEventListener('click', () => {
             if (socket && currentCallId) {
                 logMessage("Stopping screen share...");
                 socket.emit('screen_share_stop', { callId: currentCallId });
                 stopScreenShareBtn.disabled = true;
                 // Switch local stream back to camera (requires re-getting user media)
             }
        });

        // --- Initialize ---
        connectSocket();

    </script>
</body>
</html>